#!/bin/bash

set -e  #to automatically exit out if the script command exits with a "non-zero" status

####Defining pathways
toplvl=/home/angelw/Data/vismod_analysis/raw_mri_data/bids_structure  #set this directory to the top level folder you want to move things into
dcmdir=/home/angelw/Data/vismod_analysis/raw_mri_data/bids_structure/dicom/bdd		# For BDD subjects  #set this to dicom group 1 folder
dcmdir=/home/angelw/Data/vismod_analysis/raw_mri_data/bids_structure/dicom/con		# For CON subjects #set this to dicom group 2 folder
dcm2niidir=/home/angelw/mricrogl
#my dcm2niidir=/usr/local/Cellar ???


#Create nifti directory
niidir=${toplvl}/nifti/bdd		# For BDD subjects
niidir=${toplvl}/nifti/con		# For CON subjects

###Create dataset_description.json
jo -p "Name"="BDD Visual Modulation and Rest Dataset" "BIDSVersion"="1.0.2" >> ${niidir}/dataset_description.json
#adds a json file using the jo package and command from the file set in a separate folder "dataset_description"


for subj in 5019; do  #change this to the folder you want it to be
	echo "Processing subject $subj"

	####Anatomical Organization####
	###Create structure
	mkdir -p ${niidir}/sub-${subj}/anat #the -p function makes so that intermediate directories are created if needed or skipped if exist
	#automatically sets permissions as 0777 (want to change to 770 * later)

	###Convert dcm to nii
	#Only convert the Dicom folder anat
	cd ${dcmdir}/${subj}
	for direcs in *MPRAGE*; do
		${dcm2niidir}/dcm2niix -o ${niidir}/sub-${subj} -f ${subj}_%p_%s ${dcmdir}/${subj}/${direcs}
		#explanations for above
		#general format :: dcm2niix [options] <in_folder>
		#${dcm2niidir}#go to the dcm directory folder where dcm2niix function is
		#/dcm2niix -o # set the output directory as follows: ${niidir}/sub-${subj} #nifti folder created for the subject
		# -f #name the file as filename:: ${subj}_%p#protocolused_%s#seriesused
		#${dcmdir}/${subj}/${direcs} #files within within the dicom subject folder, in the MPRAGE directories
	done

	#Changing directory into the subject folder
	cd ${niidir}/sub-${subj}

	###Change filenames
	##Rename anat files
	#Example filename: 5015_t1_mprage_sag_p3_iso_8
	#BIDS filename: sub-5015_T1w
	#Capture the number of anat files to change
	anatfiles=$(ls -1 *mprage* | wc -l) #collect all the anat files and count the number of files with MPRAGE #this is a numerical variable
	for ((i=1;i<=${anatfiles};i++)); do #every time loop through the function, add 1 to the i (second run through, i=2, etc; then only cont if 2 or more MPRAGE)
 #(#initialization;condition;loop)
		Anat=$(ls *mprage*) #This is to refresh the Anat variable, if this is not in the loop,
		#each iteration a new "No such file or directory error", this is because the filename was changed.
		#save the filenames in the Anat variables
		tempanat=$(ls -1 $Anat | sed '1q;d') #grab the first filename within Anat variables
		#grab entire filename
		#Capture new file to change ##pipe one Anat line into stream editor,
		#1=buffer the ouput line, q= branch to the end of the script and quit the sed function so doesn't keep reading and take awhile
		#;= , d=delete the first line and start next cycle ????????????
		tempanatext="${tempanat##*.}" ##what does ##*. mean????????????? #grab the filename after the . sign
		#copy the extension of the filename (cosiders the last .)
		tempanatfile="${tempanat%.*}" ##what is %.*?????????? #grab before the . sign
		#save the filename without the extension (cosiders the last .)
		mv ${tempanatfile}.${tempanatext} sub-${subj}_T1w.${tempanatext} #rename the file
		echo "${tempanat} changed to sub-${subj}_T1w.${tempanatext}" #echo what the script did
	done

	###Organize files into folders
	for files in $(ls sub*); do
		Orgfile="${files%.*}"
		Orgext="${files##*.}"
		Modality=$(echo $Orgfile | rev | cut -d '_' -f1 | rev)
		#reversethe order of characters in the file
		#remove the delimiter separated by underscore (the -f1 says the remove the first field of the delimeter??? Is this in regards to the reverse order?)
		#reverse the order again
		if [ $Modality == "T1w" ]; then
			mv ${Orgfile}.${Orgext} anat
		fi
	done

	#Rename all *.gz to *.nii.gz
	cd ${niidir}/sub-${subj}/anat
	for niifiles in *.gz; do
		mv -- "$niifiles" "${niifiles%.gz}.nii.gz"
	done

	####Diffusion Organization####
	#Create subject folder
	mkdir -p ${niidir}/sub-${subj}/dwi

	###Convert dcm to nii
	#Converting the two diffusion Dicom directories
	cd ${dcmdir}/${subj}
	for direcs in *DWI*; do
		${dcm2niidir}/dcm2niix -o ${niidir}/sub-${subj} -f ${subj}_%p_%s ${dcmdir}/${subj}/${direcs}
	done

	#Changing directory into the subject folder
	cd ${niidir}/sub-${subj}

	#change dwi
	#Example filename: 5015_DWI_dir99_AP_7
	#BIDS filename: sub-5015_dwi
	#difffiles will capture how many filenames to change
	difffiles=$(ls -1 *DWI* | wc -l)
	for ((i=1;i<=${difffiles};i++)); do
		Diff=$(ls *DWI*) #This is to refresh the diff variable, same as the cases above.
		tempdiff=$(ls -1 $Diff | sed '1q;d')
		tempdiffext="${tempdiff##*.}"
		tempdifffile="${tempdiff%.*}"
		mv ${tempdifffile}.${tempdiffext} sub-${subj}_dwi.${tempdiffext}
		echo "$tempdiff changed to sub-${subj}_dwi.${tempdiffext}"
	done

	###Organize files into folders
	for files in $(ls sub*); do
		Orgfile="${files%.*}"
		Orgext="${files##*.}"
		Modality=$(echo $Orgfile | rev | cut -d '_' -f1 | rev)
		if [ $Modality == "dwi" ]; then
			mv ${Orgfile}.${Orgext} dwi
		fi
	done

	#Rename all *.gz to *.nii.gz
	cd ${niidir}/sub-${subj}/dwi
	for niifiles in *.gz; do
		mv -- "$niifiles" "${niifiles%.gz}.nii.gz"
	done

	####Functional Organization####
	#Create subject folder
	mkdir -p ${niidir}/sub-${subj}/func

	###Convert dcm to nii
	cd ${dcmdir}/${subj}
	for direcs in VIS_MOD_1_* VIS_MOD_2_* VIS_MOD_3_* REST*; do
		#grab the directories within each functional task folders
		${dcm2niidir}/dcm2niix -o ${niidir}/sub-${subj} -f ${subj}_%p_%s ${dcmdir}/${subj}/${direcs}
	done

	#Changing directory into the subject folder
	cd ${niidir}/sub-${subj}

	##Rename func files
	#Break the func down into each task
	#VIS_MOD task
	#Example filename: 5015_VIS_MOD_1_Nat_tilt-12_5
	#BIDS filename: sub-5015_task-VISMOD1Nat_bold
	#Capture the number of files to change
	vismodfiles=$(ls -1 *VIS_MOD* | wc -l)
	#caputure the number of total vismod functional task files
	for ((i=1;i<=${vismodfiles};i++)); do
		vismod=$(ls *VIS_MOD*) #This is to refresh the vismod variable, same as the Anat case
		tempvismod=$(ls -1 $vismod | sed '1q;d') #Capture new file to change
		tempvismodext="${tempvismod##*.}"
		tempvismodfile="${tempvismod%.*}"
		taskname=$(echo $tempvismodfile | awk -F'[_]' '{print $2$3$4$5}')
		#natural viewing is always first but the second task is counterbalanced
		#awk -F'[_]' '{print $2$3$4$5}'   #separate out by the underscores into 7 different fields
		#only grab the 2-5 fields as the task names
		mv --backup=numbered ${tempvismodfile}.${tempvismodext} sub-${subj}_task-${taskname}_bold.${tempvismodext}
		#always backup so that you don't rewrite the filenames
		#this makes a ~1~ if there are more than one
		echo "${tempvismodfile}.${tempvismodext} changed to sub-${subj}_task-${taskname}_bold.${tempvismodext}"
	done

	#Rest
	#Example filename: 5015_Rest_MB8_1_9
	#BIDS filename: sub-5015_task-rest_bold
	#Capture the number of files to change
#some subjects have zero rest files, some have only 1 but it's the 7 min rest, others the 5 min rest, some subjects have both rests
	restfiles=$(ls -1 *Rest* | wc -l)
	for ((i=1;i<=${restfiles}/2;i++)); do
		restnii=$(ls *Rest*nii*)
		temprestnii=$(ls -1 $restnii | sed '1q;d')
		tp=`fslnvols $temprestnii` #this function captures the number of timepoints for the nii files with an FSL function
#tp is a numerical vaiable with the number of volumes within that functional data (570 for 7 min, 406 for 5 min)
		for ((j=1;j<=2;j++)); do
			rest=$(ls *Rest*) #This is to refresh the rest variable, same as the Anat case
			temprest=$(ls -1 $rest | sed '1q;d') #Capture new file to change
			temprestext="${temprest##*.}"
			temprestfile="${temprest%.*}"
			mv --backup=numbered ${temprestfile}.${temprestext} sub-${subj}_task-rest_acq-${tp}TP_bold.${temprestext}
			echo "${temprestfile}.${temprestext} changed to sub-${subj}_task-rest_acq-${tp}TP_bold.${temprestext}"
		done
	done

	###Organize files into folders
	for files in $(ls sub*); do
		Orgfile="${files%.*}"
		Orgext="${files##*.}"
		Modality=$(echo $Orgfile | rev | cut -d '_' -f1 | rev)
		if [ $Modality == "bold" ]; then
			mv ${Orgfile}.${Orgext} func
		fi
	done

	#Handle duplicate files
	if ls *~* 1> /dev/null 2>&1; then #look for ~ to indicate a file that has the backup rest because there is more than one rest of the same length
		for file in *~*; do
			dupfile="${file%.*}"
			dupext="${file##*.}"
			dupnum=$(echo $file | awk -F'[~]' '{print $2}') #print the second field between the tildes (~1~ captures and prints 1)
			mv $file ${file//.${dupext}/}
			mv $dupfile ${dupfile//TP/TP${dupnum}}
		done
		mv sub*TP* func
		cd func
		((newnum=$dupnum+1))
		for file in *TP_*; do
			mv $file ${file//TP/TP${newnum}}
		done
	fi

	#Rename all *.gz to *.nii.gz
	cd ${niidir}/sub-${subj}/func
	rename .gz .nii.gz *.gz*

	###Check func json for required fields
	#Required fields for func: 'RepetitionTime','VolumeTiming' or 'SliceTiming', and 'TaskName'
	#capture all jsons to test
	cd ${niidir}/sub-${subj}/func #Go into the func folder
	for funcjson in $(ls *.json*); do

		#Repeition Time exist?
		repeatexist=$(cat ${funcjson} | jq '.RepetitionTime')
		if [[ ${repeatexist} == "null" ]]; then
			echo "${funcjson} doesn't have RepetitionTime defined"
		else
			echo "${funcjson} has RepetitionTime defined"
		fi

		#VolumeTiming or SliceTiming exist?
		#Constraint SliceTiming can't be great than TR
		volexist=$(cat ${funcjson} | jq '.VolumeTiming')
		sliceexist=$(cat ${funcjson} | jq '.SliceTiming')
		if [[ ${volexist} == "null" && ${sliceexist} == "null" ]]; then
			echo "${funcjson} doesn't have VolumeTiming or SliceTiming defined"
		else
			if [[ ${volexist} == "null" ]]; then
				echo "${funcjson} has SliceTiming defined"
				#Check SliceTiming is less than TR
				sliceTR=$(cat ${funcjson} | jq '.SliceTiming[] | select(.>="$repeatexist")')
				if [ -z ${sliceTR} ]; then
					echo "All SliceTiming is less than TR" #The slice timing was corrected in the newer dcm2niix version called through command line
				else
					echo "SliceTiming error"
				fi
			else
				echo "${funcjson} has VolumeTiming defined"
			fi
		fi

		#Does TaskName exist?
		taskexist=$(cat ${funcjson} | jq '.TaskName')
		if [ "$taskexist" == "null" ]; then
			jsonname="${funcjson%.*}"
			taskfield=$(echo $jsonname | cut -d '_' -f2 | cut -d '-' -f2)
			jq '. |= . + {"TaskName":"'${taskfield}'"}' ${funcjson} > tasknameadd.json
			rm ${funcjson}
			mv tasknameadd.json ${funcjson}
			echo "TaskName was added to ${jsonname} and matches the tasklabel in the filename"
		else
			Taskquotevalue=$(jq '.TaskName' ${funcjson})
			Taskvalue=$(echo $Taskquotevalue | cut -d '"' -f2)
			jsonname="${funcjson%.*}"
			taskfield=$(echo $jsonname | cut -d '_' -f2 | cut -d '-' -f2)
			if [ $Taskvalue == $taskfield ]; then
				echo "TaskName is present and matches the tasklabel in the filename"
			else
				echo "TaskName and tasklabel do not match"
			fi
		fi

	done
done
